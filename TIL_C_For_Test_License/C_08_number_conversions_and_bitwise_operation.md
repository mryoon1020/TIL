여기에 기록되는 모든 내용은 유튜브 흥달쌤 채널의 강의에서 개인 공부 목적으로 기록함

링크 : https://www.youtube.com/watch?v=-w6O5Bq8OMY&list=PLdaE6YENrbZA8sXCvVBUWjFwFI2zb4tlK&index=2

# 11강 진법변환, 비트연산

### 진법 변환

- **10진수 => 2진수**
  - 2로 계속 나누는 방법

|      |  19  |  C   |
| :--: | :--: | :--: |
|  2   |  9   |  1   |
|  2   |  4   |  1   |
|  2   |  2   |  0   |
|  2   |  1   |  0   |

- 19 => 10011	
  - 또다른 방법
  - 같은 원리, 좀더 빠른방법

|  32  |  16  |  6   |  4   |  2   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  0   |  0   |  1   |  1   |

- **2진수 => 8진수**

|  0   |  1   |  0   |  0   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  4   |  2   |  1   |  4   |  2   |  1   |
|  0   |  2   |  0   |  0   |  2   |  1   |

- 19 => 10011 => 23
  - 각자리별로 더한다
- 2진수 => 16진수

|  0   |  0   |  0   |  1   |  0   |  0   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  8   |  4   |  2   |  1   |  8   |  4   |  2   |  1   |
|      |      |      |  1   |      |      |  1   |  1   |

- 19 => 10011 => 13

### 비트연산자

- 비트연산에서는 기존에 교과과정에서 배운 2진수 계산과 다름
  - 1 + 1 = ? 
  -  정답 : 1
  - 이유: 참(true) + 참(true) = 참(true)

- 종류

| 기호 |          의미           |            해석             |   예    | 결과 |
| :--: | :---------------------: | :-------------------------: | :-----: | :--: |
|  &   |    비트 논리곱(AND)     |  두개 모두 참일 때 참이 됨  |  5 & 3  |  1   |
|  \|  |     비트 논리합(OR)     | 둘중 하나만 참일 때 참이 됨 | 5  \| 5 |  7   |
|  ^   | 비트 배타적 논리합(XOR) |  두개 모두 틀려야 참이 됨   |  5 ^ 3  |  6   |
|  ~   |        비트 NOT         |         계산해야함          |   ~ 5   |  -6  |
|  >>  | 비트값을 우측으로 이동  |           5 >> 3            | 5 >> 3  |      |
|  <<  | 비트값을 좌측으로 이동  |           5 << 3            | 5 << 3  |      |

- 논리곱

|      |  1   |  0   |  0   |  1   |  1   |  19  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  &   |  0   |  1   |  1   |  0   |  1   |  13  |
|      |  0   |  0   |  0   |  0   |  1   |  1   |

- 논리합

|      |  1   |  0   |  0   |  1   |  1   |  19  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  \|  |  0   |  1   |  1   |  0   |  1   |  13  |
|      |  1   |  1   |  1   |  1   |  1   |  31  |

- 비트 NOT (~ 연산자)
  - 양수 : 절대값에 +1 한후 -(음수)로 변환
  - 음수 : 절대값에 -1 한후 +(양수)로 변환

| ~ 16   | - 17 |
| ------ | ---- |
| ~ - 16 | 15   |

- 예제(2010 국가직 9급 프로그래밍 언어론)

```C
#include<stdio.h>
void main(){
    int x = 0x11;
    int y, z;
    y = x & 0x0f;
    z = x | 0x0f;
    printf("x=%d, y=%d, z=%d", x, y, z);
}

//해설
0x11 => 16진수 11이라는 수라는 뜻
0x11 => 2진수 변환
4 3 2 1 // 4 3 2 1
0 0 0 1    0 0 0 1
0x11 = 00010001
0x0f = 00001111

y =	x & 0x0f;
=> 00010001
   00001111
=> 00000001 => y = 1
z = x | 0x0f
=> 00010001
   00001111
=> 00011111 => z = 16 + 8 + 4 + 2 + 1 => 31
출력결과 : x=17 , y=1, z=31
```

> 16진수
>
> - 16진수의 한자리는 다음의 수가 올수 있음
> - 예 :  `16 = f` // `255 = ff` // `4095 = fff`  // `3885 = f2d`
>
> |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |  15  |
> | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
> |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  A   |  B   |  C   |  D   |  E   |  F   |

여기에 기록되는 모든 내용은 유튜브 흥달쌤 채널의 강의에서 개인 공부 목적으로 기록함

링크 : https://www.youtube.com/watch?v=-w6O5Bq8OMY&list=PLdaE6YENrbZA8sXCvVBUWjFwFI2zb4tlK&index=2

# 12강 매크로, 비트연산

### 매크로

- 반복적인 일들을 쉽게하기 위해 만들어 놓은것

- 함수와 차이점 : 
  - 함수 : 한번 호출하면 다시 사라짐
  - 매크로 : 모든 프로그램에 공통적으로 들어갈수 있음, 전처리기에서 선언하기 때문
- 선언방법
  - `#define N 10`
    - 모든 N은 10으로 대체한다 라는 뜻
  - `#define SQR(x) x*x`
    - x 라는 인자를 받게되면 x*x를 수행한다 라는 뜻
- 예제

```c
#define N 10
#define SQR(x) x*x

SQR(N); // SQR(10) => 100 출력
SQR(N+2); // SQR(N+2) => N + 2 * N + 2 => 10 + 2 * 10 + 2 => 10 + 20 + 2 => 32 출력
//단, 매크로 일 떄만 이렇게 수행됨
```

### 비트연산자

| 기호 |          의미           |            해석             |   예    | 결과 |
| :--: | :---------------------: | :-------------------------: | :-----: | :--: |
|  &   |    비트 논리곱(AND)     |  두개 모두 참일 때 참이 됨  |  5 & 3  |  1   |
|  \|  |     비트 논리합(OR)     | 둘중 하나만 참일 때 참이 됨 | 5  \| 5 |  7   |
|  ^   | 비트 배타적 논리합(XOR) |  두개 모두 틀려야 참이 됨   |  5 ^ 3  |  6   |
|  ~   |        비트 NOT         |         계산해야함          |   ~ 5   |  -6  |
|  >>  | 비트값을 우측으로 이동  |           5 >> 3            | 5 >> 3  |      |
|  <<  | 비트값을 좌측으로 이동  |           5 << 3            | 5 << 3  |      |

- 시프트 연산(>>)
  - 10 >> 2
    - 10을 우측으로 2개 밀라는 뜻
    - 10 => 10 <u>**10**</u>
    - 1010 >> 2 => 10
    - 10 >> 2 => 2

- 시프트 연산(>>)
  - 10 << 2
    - 10 => 1010
    - 1010 << 2 => 1010 <u>**00**</u>
    - 1010 << 2 => 101000
    - 10 << 2 => 40

- 예제(2010계리직 컴퓨터 일반)

```c
#define VALUE1 1
#define VALUE2 2
main(){
    float i;
    int j, k, m;
    i = 100 / 300;
    j = VALUE1 & VALUE2;
    K = VALUE1 | VALUE2;
    if(j && k || i)m = i + j;
    else m = j + k;
    printf("i = %.1f j = %d k = %d m = %03d\n", i, j, k, m);
}
//정답
i = 0.0 j = 0 k = 3 m =003
    
//풀이
i = 100 / 300 => i는 float으로 실수를 받지만 어쨌든, 정수/정수 => 정수임을 벗어날 수 없음
  = 0
j = VALUE1 & VALUE2 => 매크로로 인해 1 & 2 변환
    1 => 0001
    2 => 0010
    1 & 2 => 비트연산, 곱연산(둘다 모두 참 이어야 참) => 0000
  = 0
k = VALUE1 | VALUE2 => 매크로로 인해 1 | 2 변환
    1 => 0001
    2 => 0010
    1 | 2 => 비트연산, 합연산(둘중 하나만 참이어도 참) => 0011
  = 3
m = if문 조건 확인 필요
   if문 조건 => j && k || i => 연산자 우선순위가 동일하므로 앞에서 부터 연산
    		=> 0 && 3 => 거짓 (0은 항상 거짓임, &&연산은 둘중하나라도 거짓이면 거짓)
    		=> 0 || 0 => 거짓 (||연산은 둘중하나만 참이어도 참, 여기서는 둘다 거짓이므로 결과는 거짓)
    		=> if 문 실행 안됨 => else문 실행
   else문 => m = j + k => 0 + 3
  = 3
출력 - 출력형식 자료 참조
    printf("i = %.1f j = %d k = %d m = %03d\n", i, j, k, m);
i = %.1f => 소수점 첫째 자리까지 표기 => 0.0
j = %d => 부호가 있는 정수 표기 => 0
k = %d => 부호가 있는 정수 표기 => 3
m = %03d => 공간을 3개 만든뒤 빈공간에는 0을 채워서 표기 => 003
```