여기에 기록되는 모든 내용은 유튜브 흥달쌤 채널의 강의에서 개인 공부 목적으로 기록함

링크 : https://www.youtube.com/watch?v=-w6O5Bq8OMY&list=PLdaE6YENrbZA8sXCvVBUWjFwFI2zb4tlK&index=2

# 36강 배열포인터

### 배열포인터

- 배열의 시작 주소값을 저장할 수 있는 포인터
- 2차원 배열의 구조
- 그냥하나의 포인터일 뿐이

> 예시

```c
int (*in)[2];
int num[3] = {1, 2, 3};
in = num;

printf("%d\n", in);
printf("%d\n", num);
printf("%d\n", *in);
```

- 도식화

| num  | num[0] | num[1] | num[2] |
| ---- | ------ | ------ | ------ |
| 100  | 1      | 2      | 3      |

- `int (*in)[2];`
  - 배열을 2개씩 알아서 자르겠다라는 뜻
  - 다음 표와 같은 2차원 배열로 잘림
- `in = num;` 실행 결과
  - 물리적으로는 그대로이며 논리적으로만 잘림


| in   | in[0]     | 100     | 1     | 2    |
| ---- | --------- | ------- | ----- | ---- |
| 100  | **in[1]** | **102** | **3** |      |

- `printf("%d\n", in);` => 주소값인 100 이 출력됨
- `printf("%d\n", num);` => 주소값인 100이 출력됨
- `printf("%d\n", *in);` => 주소값인 100 이 출력

- `printf("%d\n", **in);` => in의 값의 값 => in은 100 가리킴 => in이 가지고 있는 100의 값은 a[0]의 주소를 가리키고있음 => 따라서 in의 값은 100이 됨 => 출력은 in의 값의 값이므로  => 100이 가리키고있는 값 = 1 => 1이 출력됨
- `printf("%d\n", *(*in+1));` => 100 + 1 => 101의 값 => 2 출력
- `printf("%d\n", *(*in+2));` => 100 + 2 => 102의 값 => 3 출력
- `printf("%d\n", *in[1]);` => in[1] = 102 => 102의 값 => 3 출력

> 예시2

```c
int (*in)[4];
int num[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
in = num;
```

- 도식화

| num  | num[0]     | 100     | 1     | 2     | 3     |
| ---- | ---------- | ------- | ----- | ----- | ----- |
| 100  | **num[1]** | **103** | **4** | **5** | **6** |
|      | **num[2]** | **106** | **7** | **8** | **9** |
- `in = num;` 실행 결과
| in   | in[0]     | 100     | 1     | 2     | 3     | 4     |
| ---- | --------- | ------- | ----- | ----- | ----- | ----- |
| 100  | **in[1]** | **104** | **5** | **6** | **7** | **8** |
|      | **in[2]** | **108** | **9** |       |       |       |

- `printf("%d\n", **in);` => in의 값 = 100 => 100의 값 = 1 => 1 출력
- `printf("%d\n", *(*in+1));` => in의 값 = 100 => 100 + 1 => 101의 값 => 2 출력
- `printf("%d\n", **(in+1));` => in의 값이 아닌 in이므로 in[0]를 가르키고 있음 => in[0] + 1 = in[0] 다음 원소 = in[1] => in[1]의 값 = 104 => 104의 값 = 5 => 5 출력

> 예제 (2019 서울시 9급 컴퓨터 일반)

- malloc() => 동적으로 메모리에 할당하는 함수(변수선언시 크기를 정해준다고 생각하면 됨)

```c
#include<stdio.h>
#include<stdlib.h>
#define N 3
int main(void){
    int (*in)[N], *out, sum=0;
    in = (int (*)[N]), malloc(N * N * sizeof(int));
    out = (int *) in;
    for(int i = 0; i < N * N; i++) out[i] = i;
    for(int i = 0; i < N; i++)
        sum += in[i][i];
    printf("%d", sum);
    return 0;
}
```

- 매크로실행 후 메인

```c
int main(void){
    int (*in)[3], *out, sum=0;
    in = (int (*)[3]), malloc(3 * 3 * sizeof(int));
    out = (int *) in;
    for(int i = 0; i < 3 * 3; i++) out[i] = i;
    for(int i = 0; i < 3; i++)
        sum += in[i][i];
    printf("%d", sum);
    return 0;
}
```

- `int (*in)[3]` => 논리적으로 3개씩 짤라서 재구성한다라는 뜻
- `(int (*)[3]), malloc(3 * 3 * sizeof(int)` 
  - sizeof(int) => 사이즈가 int인 => int = 4 byte
  - 사이즈가 4 byte인 크기가 3행 3열인 배열을 만들겠다라는 뜻

- `in = (int (*)[3]), malloc(3 * 3 * sizeof(int));` 
  - 9개짜리 배열을 생성하여 3개씩 자르겠다라는 뜻
- 도식화

| in   | in[0]     | 100     |      |      |      |
| ---- | --------- | ------- | ---- | ---- | ---- |
| 100  | **in[1]** | **103** |      |      |      |
| out  | **in[2]** | **106** |      |      |      |
| 100  | X         | X       | X    | X    | X    |

- `for(int i = 0; i < 3 * 3; i++) out[i] = i;` 실행결과

| in      | in[0]     | 100     | 0     | 1     | 2     |
| ------- | --------- | ------- | ----- | ----- | ----- |
| 100     | **in[1]** | **103** | **3** | **4** | **5** |
| **out** | **in[2]** | **106** | **6** | **7** | **8** |
| 100     | X         | X       | X     | X     | X     |

- `for(int i = 0; i < 3; i++) sum += in[i][i];` 실행결과
  - sum = 12
- `printf("%d", sum);` => 12 출력
